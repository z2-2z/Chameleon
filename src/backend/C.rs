use crate::{
    Args,
    frontend::SourceView,
    grammar::{
        Grammar, StringId, NumbersetId, NumbersetType,
        Numberset, ContainerId, Container, ContainerType,
        Variable, VariableType, IntegerValue, BytearrayValue,
        Scheduling, HasOptions, Endianness, ContainerOptions,
        Depth,
    },
    backend::formatter::CodeFormatter,
    emit_raw, emit_line,
};
use std::ops::Range;
use num_traits::{
    Num, cast::NumCast, bounds::Bounded,
    ops::wrapping::{WrappingAdd, WrappingSub},
};
use std::fmt::Display;

fn emit_header(prod: &mut CodeFormatter, args: &Args, options: &ContainerOptions) {
    emit_raw!(
        prod,
"
/************************************
     Auto-generated by Chameleon

              Parameters
             ~~~~~~~~~~~~
  Grammar: {}
  Forbid cycles: {}
  Global endianness: {}
  Global scheduling: {}
  Depth: {}
 ************************************/
 ",
        &args.grammar,
        args.forbid_cycles,
        match options.endianness() {
            Endianness::Little => "little",
            Endianness::Big => "big",
            Endianness::Native => "native",
        },
        match options.scheduling() {
            Scheduling::RoundRobin => "round-robin",
            Scheduling::Random => "random",
        },
        match options.depth() {
            Depth::Unlimited => "unlimited".to_string(),
            Depth::Limited(limit) => format!("{}", limit),
        }
    );
}

fn emit_includes(prod: &mut CodeFormatter) {
    emit_raw!(
        prod,
"
#include <stddef.h>
#include <stdint.h>
#include <endian.h>
"
    )
}

fn emit_macros(prod: &mut CodeFormatter) {
    emit_raw!(
        prod,
"
#define UNLIKELY(x) __builtin_expect(!!(x), 0)
#define LIKELY(x) __builtin_expect(!!(x), 1)

#ifndef __clang__
#define __builtin_memcpy_inline __builtin_memcpy
#endif

// Mark globals as thread local only if we are doing multithreading
#ifdef MULTITHREADING
#define THREAD_LOCAL __thread
#else
#define THREAD_LOCAL
#endif

// Define the compile-time seed
#ifndef SEED
#define SEED 0x35c6be9ba2548264
#endif

// Define endianness helper functions
#define LITTLE_ENDIAN_16(x) htole16((uint16_t) (x))
#define BIG_ENDIAN_16(x)    htobe16((uint16_t) (x))
#define LITTLE_ENDIAN_32(x) htole32((uint32_t) (x))
#define BIG_ENDIAN_32(x)    htobe32((uint32_t) (x))
#define LITTLE_ENDIAN_64(x) htole64((uint64_t) (x))
#define BIG_ENDIAN_64(x)    htobe64((uint64_t) (x))
"
    );
}

fn emit_rng(prod: &mut CodeFormatter, args: &Args) {
    emit_raw!(
        prod,
"
// RNG: xorshift64
static THREAD_LOCAL uint64_t rand_state = SEED;

#ifndef DISABLE_rand
static uint64_t rand() {{
    uint64_t x = rand_state;
    x ^= x << 13;
    x ^= x >> 7;
    x ^= x << 17;
    return rand_state = x;
}}
#else
uint64_t rand();
#endif

#ifndef DISABLE_seed
void {0}seed(size_t s) {{
    if (s) {{
        rand_state = (uint64_t) s;
    }} else {{
        rand_state = SEED;
    }}
}}
#else
void {0}seed(size_t);
#endif
",
        &args.prefix,
    );
}

fn emit_helpers(prod: &mut CodeFormatter) {
    emit_raw!(
        prod,
"
// Helper method that writes random data into a buffer
#define MASK_BYTES 0xFFFFFFFFFFFFFFFFUL
#define MASK_STRING 0x7F7F7F7F7F7F7F7FUL
#ifndef DISABLE_random_buffer
static void random_buffer (unsigned char* buf, uint32_t len, uint64_t mask) {{
    while (len >= 8) {{
        *(uint64_t*)buf = rand() & mask;
        buf += 8; len -= 8;
    }}
    
    while (len >= 4) {{
        *(uint32_t*)buf = (uint32_t) (rand() & mask);
        buf += 4; len -= 4;
    }}
    
    while (len >= 2) {{
        *(uint16_t*)buf = (uint16_t) (rand() & mask);
        buf += 2; len -= 2;
    }}
    
    while (len >= 1) {{
        *buf = (unsigned char) (rand() & mask);
        buf += 1; len -= 1;
    }}
}}
#else
void random_buffer (unsigned char* buf, uint32_t len, uint64_t mask);
#endif
"
    );
}

fn string_var(id: &StringId) -> String {
    format!("string_{}", id)
}

fn emit_strings(prod: &mut CodeFormatter, grammar: &Grammar) {
    if grammar.strings().len() > 0 {
        emit_raw!(prod, "\n// Strings from grammar\n");
        
        for (id, bts) in grammar.strings().iter() {
            emit_raw!(prod, "static const unsigned char {}[{}] = {{", string_var(id), bts.len());
            
            for i in 0..bts.len() - 1 {
                emit_raw!(prod, "{:#02x}, ", bts[i]);
            }
            emit_raw!(prod, "{:#02x}", bts[bts.len() - 1]);
            
            emit_raw!(prod, "}};\n");
        }
    }
}

fn numberset_func(id: &NumbersetId) -> String {
    format!("numberset_{}", id)
}

fn numberset_c_type(typ: &NumbersetType) -> &str {
    match typ {
        NumbersetType::U8(_) => "uint8_t",
        NumbersetType::I8(_) => "int8_t",
        NumbersetType::U16(_) => "uint16_t",
        NumbersetType::I16(_) => "int16_t",
        NumbersetType::U32(_) => "uint32_t",
        NumbersetType::I32(_) => "int32_t",
        NumbersetType::U64(_) => "uint64_t",
        NumbersetType::I64(_) => "int64_t",
    }
}

fn emit_range_selection<R>(prod: &mut CodeFormatter, range: &Range<R>, c_type: &str, suffix: &str) 
where
    R: Display + Ord + Num + NumCast + Copy + Bounded + WrappingAdd + WrappingSub,
{
    let zero = R::from(0).unwrap();
    let one = R::from(1).unwrap();
    let min_value = R::min_value();
    
    let start_format = if range.start.cmp(&min_value) == std::cmp::Ordering::Equal && range.start.cmp(&zero) != std::cmp::Ordering::Equal {
        format!("({0}{1} - 1{1})", min_value + one, suffix)
    } else {
        format!("{}{}", range.start, suffix)
    };
    
    if range.end == range.start {
        emit_line!(prod, "return {};", start_format);
    } else {
        emit_line!(prod, "uint64_t range_selector = rand();");
        
        let delta: R = range.end.wrapping_sub(&range.start).wrapping_add(&one);
        
        if delta.cmp(&zero) == std::cmp::Ordering::Equal {
            emit_line!(prod, "return (({}) range_selector) + {};", c_type, start_format);
        } else {
            emit_line!(prod, "return ((({}) range_selector) % {}{}) + {};", c_type, delta, suffix, start_format);
        }
    }
}

fn emit_single_numberset<R>(prod: &mut CodeFormatter, numberset: &Numberset<R>, c_type: &str, suffix: &str)
where
    R: Display + Ord + Num + NumCast + Copy + Bounded + WrappingAdd + WrappingSub,
{
    if numberset.len() == 1 {
        emit_range_selection(prod, &numberset[0], c_type, suffix);
    } else {
        emit_line!(prod, "uint64_t numberset_selector = rand() % {};", numberset.len());
        
        emit_line!(prod, "switch(numberset_selector) {{");
        prod.block_open();
        
        for case in 0..numberset.len() {
            emit_line!(prod, "case {}: {{", case);
            prod.block_open();
            emit_range_selection(prod, &numberset[case], c_type, suffix);
            prod.block_close();
            emit_line!(prod, "}}");
        }
        
        emit_line!(prod, "default: {{");
        prod.block_open();
        emit_line!(prod, "__builtin_unreachable();");
        prod.block_close();
        emit_line!(prod, "}}");
        
        prod.block_close();
        emit_line!(prod, "}}");
    }
}

fn emit_numbersets(prod: &mut CodeFormatter, grammar: &Grammar) {
    if grammar.numbersets().len() > 0 {
        emit_raw!(prod, "\n// Numbersets from grammar\n");
        
        for (id, numberset) in grammar.numbersets().iter() {
            let c_type = numberset_c_type(numberset);
            emit_line!(prod, "static {} {}() {{", c_type, numberset_func(id));
            prod.block_open();
            
            match numberset {
                NumbersetType::U8(numberset) => emit_single_numberset(prod, numberset, c_type, "U"),
                NumbersetType::I8(numberset) => emit_single_numberset(prod, numberset, c_type, ""),
                NumbersetType::U16(numberset) => emit_single_numberset(prod, numberset, c_type, "U"),
                NumbersetType::I16(numberset) => emit_single_numberset(prod, numberset, c_type, ""),
                NumbersetType::U32(numberset) => emit_single_numberset(prod, numberset, c_type, "U"),
                NumbersetType::I32(numberset) => emit_single_numberset(prod, numberset, c_type, ""),
                NumbersetType::U64(numberset) => emit_single_numberset(prod, numberset, c_type, "ULL"),
                NumbersetType::I64(numberset) => emit_single_numberset(prod, numberset, c_type, "LL"),
            }
            
            prod.block_close();
            emit_line!(prod, "}}");
        }
    }
}

fn container_func(id: &ContainerId) -> String {
    format!("container_{}", id)
}

fn emit_declarations(prod: &mut CodeFormatter, grammar: &Grammar) {
    emit_raw!(prod, "\n// Forward declarations of containers\n");
    
    for container in grammar.containers() {
        match grammar.options().depth() {
            Depth::Unlimited => {
                emit_line!(prod, "static size_t {}(unsigned char*, size_t);", container_func(&container.id()));
            },
            Depth::Limited(_) => {
                emit_line!(prod, "static size_t {}(unsigned char*, size_t, uint64_t);", container_func(&container.id()));
            },
        }
    }
}

fn emit_variable(prod: &mut CodeFormatter, grammar: &Grammar, variable: &Variable, options: &ContainerOptions) -> bool {
    let mut label_ref = false;
    
    if variable.options().optional() {
        let depth_cond = match options.depth() {
            Depth::Unlimited => "".to_string(),
            Depth::Limited(limit) => format!("(depth < {}ULL) && ", limit),
        };
        
        emit_line!(prod, "if ({}(rand() & 1)) {{", depth_cond);
        prod.block_open();
    }
    
    if let Some(id) = variable.options().repeats() {
        match options.depth() {
            Depth::Unlimited => {
                emit_line!(prod, "uint32_t repeats_i = {}();", numberset_func(id));
            },
            Depth::Limited(limit) => {
                emit_line!(prod, "uint32_t repeats_i;");
                emit_line!(prod, "if (depth < {}UL) {{", limit);
                prod.block_open();
                emit_line!(prod, "repeats_i = {}();", numberset_func(id));
                prod.block_close();
                emit_line!(prod, "}} else {{");
                prod.block_open();
                emit_line!(prod, "repeats_i = {}U;", grammar.get_numberset_bound(*id, false));
                prod.block_close();
                emit_line!(prod, "}}");
            },
        }
        
        emit_line!(prod, "while (repeats_i--) {{");
        prod.block_open();
    }
    
    match variable.typ() {
        VariableType::I8(integer) |
        VariableType::U8(integer) => {
            label_ref = true;
            emit_line!(prod, "if (UNLIKELY(len < 1)) {{");
            prod.block_open();
            emit_line!(prod, "goto container_end;");
            prod.block_close();
            emit_line!(prod, "}}");
            
            match integer {
                IntegerValue::FromSet(id) => {
                    emit_line!(prod, "*buf = (unsigned char) {}();", numberset_func(id));
                },
                IntegerValue::Any => {
                    emit_line!(prod, "*buf = (unsigned char) rand();");
                },
            }
            emit_line!(prod, "buf += 1; len -= 1;");
        },
        VariableType::I16(integer) |
        VariableType::U16(integer) => {
            label_ref = true;
            emit_line!(prod, "if (UNLIKELY(len < 2)) {{");
            prod.block_open();
            emit_line!(prod, "goto container_end;");
            prod.block_close();
            emit_line!(prod, "}}");
            
            match integer {
                IntegerValue::FromSet(id) => {
                    emit_line!(prod, "uint16_t integer = (uint16_t) {}();", numberset_func(id));
                },
                IntegerValue::Any => {
                    emit_line!(prod, "uint16_t integer = (uint16_t) rand();");
                },
            }
            
            match options.endianness() {
                Endianness::Little => {
                    emit_line!(prod, "*(uint16_t*)buf = LITTLE_ENDIAN_16(integer);");
                },
                Endianness::Big => {
                    emit_line!(prod, "*(uint16_t*)buf = BIG_ENDIAN_16(integer);");
                },
                Endianness::Native => {
                    emit_line!(prod, "*(uint16_t*)buf = integer;");
                },
            }
            
            emit_line!(prod, "buf += 2; len -= 2;");
        },
        VariableType::I32(integer) |
        VariableType::U32(integer) => {
            label_ref = true;
            emit_line!(prod, "if (UNLIKELY(len < 4)) {{");
            prod.block_open();
            emit_line!(prod, "goto container_end;");
            prod.block_close();
            emit_line!(prod, "}}");
            
            match integer {
                IntegerValue::FromSet(id) => {
                    emit_line!(prod, "uint32_t integer = (uint32_t) {}();", numberset_func(id));
                },
                IntegerValue::Any => {
                    emit_line!(prod, "uint32_t integer = (uint32_t) rand();");
                },
            }
            
            match options.endianness() {
                Endianness::Little => {
                    emit_line!(prod, "*(uint32_t*)buf = LITTLE_ENDIAN_32(integer);");
                },
                Endianness::Big => {
                    emit_line!(prod, "*(uint32_t*)buf = BIG_ENDIAN_32(integer);");
                },
                Endianness::Native => {
                    emit_line!(prod, "*(uint32_t*)buf = integer;");
                },
            }
            
            emit_line!(prod, "buf += 4; len -= 4;");
        },
        VariableType::I64(integer) |
        VariableType::U64(integer) => {
            label_ref = true;
            emit_line!(prod, "if (UNLIKELY(len < 4)) {{");
            prod.block_open();
            emit_line!(prod, "goto container_end;");
            prod.block_close();
            emit_line!(prod, "}}");
            
            match integer {
                IntegerValue::FromSet(id) => {
                    emit_line!(prod, "uint64_t integer = (uint64_t) {}();", numberset_func(id));
                },
                IntegerValue::Any => {
                    emit_line!(prod, "uint64_t integer = (uint64_t) rand();");
                },
            }
            
            match options.endianness() {
                Endianness::Little => {
                    emit_line!(prod, "*(uint64_t*)buf = LITTLE_ENDIAN_64(integer);");
                },
                Endianness::Big => {
                    emit_line!(prod, "*(uint64_t*)buf = BIG_ENDIAN_64(integer);");
                },
                Endianness::Native => {
                    emit_line!(prod, "*(uint64_t*)buf = integer;");
                },
            }
            
            emit_line!(prod, "buf += 8; len -= 8;");
        },
        VariableType::String(bytearray) => {
            label_ref = true;
            match bytearray {
                BytearrayValue::Literal(id) => {
                    let var_name = string_var(id);
                    emit_line!(prod, "if (UNLIKELY(len < sizeof({}))) {{", var_name);
                    prod.block_open();
                    emit_line!(prod, "goto container_end;");
                    prod.block_close();
                    emit_line!(prod, "}}");
                    emit_line!(prod, "__builtin_memcpy_inline(buf, {0}, sizeof({0}));", var_name);
                    emit_line!(prod, "buf += sizeof({0}); len -= sizeof({0});", var_name);
                },
                BytearrayValue::Any(id) => {
                    match options.depth() {
                        Depth::Unlimited => {
                            emit_line!(prod, "uint32_t string_len = {}();", numberset_func(id));
                        },
                        Depth::Limited(limit) => {
                            emit_line!(prod, "uint32_t string_len;");
                            emit_line!(prod, "if (depth < {}UL) {{", limit);
                            prod.block_open();
                            emit_line!(prod, "string_len = {}();", numberset_func(id));
                            prod.block_close();
                            emit_line!(prod, "}} else {{");
                            prod.block_open();
                            emit_line!(prod, "string_len = {}U;", grammar.get_numberset_bound(*id, false));
                            prod.block_close();
                            emit_line!(prod, "}}");
                        },
                    }
                                        
                    emit_line!(prod, "if (UNLIKELY(len < string_len)) {{");
                    prod.block_open();
                    emit_line!(prod, "goto container_end;");
                    prod.block_close();
                    emit_line!(prod, "}}");
                    emit_line!(prod, "random_buffer(buf, string_len, MASK_STRING);");
                    emit_line!(prod, "buf += string_len; len -= string_len;");
                },
            }
        },
        VariableType::Bytes(bytearray) => {
            label_ref = true;
            match bytearray {
                BytearrayValue::Literal(id) => {
                    let var_name = string_var(id);
                    emit_line!(prod, "if (UNLIKELY(len < sizeof({}))) {{", var_name);
                    prod.block_open();
                    emit_line!(prod, "goto container_end;");
                    prod.block_close();
                    emit_line!(prod, "}}");
                    emit_line!(prod, "__builtin_memcpy_inline(buf, {0}, sizeof({0}));", var_name);
                    emit_line!(prod, "buf += sizeof({0}); len -= sizeof({0});", var_name);
                },
                BytearrayValue::Any(id) => {
                    match options.depth() {
                        Depth::Unlimited => {
                            emit_line!(prod, "uint32_t bytes_len = {}();", numberset_func(id));
                        },
                        Depth::Limited(limit) => {
                            emit_line!(prod, "uint32_t bytes_len;");
                            emit_line!(prod, "if (depth < {}UL) {{", limit);
                            prod.block_open();
                            emit_line!(prod, "bytes_len = {}();", numberset_func(id));
                            prod.block_close();
                            emit_line!(prod, "}} else {{");
                            prod.block_open();
                            emit_line!(prod, "bytes_len = {}U;", grammar.get_numberset_bound(*id, false));
                            prod.block_close();
                            emit_line!(prod, "}}");
                        },
                    }
                    
                    emit_line!(prod, "if (UNLIKELY(len < bytes_len)) {{");
                    prod.block_open();
                    emit_line!(prod, "goto container_end;");
                    prod.block_close();
                    emit_line!(prod, "}}");
                    emit_line!(prod, "random_buffer(buf, bytes_len, MASK_BYTES);");
                    emit_line!(prod, "buf += bytes_len; len -= bytes_len;");
                },
            }
        },
        VariableType::Oneof(id) => {
            match grammar.options().depth() {
                Depth::Unlimited => {
                    emit_line!(prod, "size_t container_len = {}(buf, len);", container_func(id));
                },
                Depth::Limited(_) => {
                    emit_line!(prod, "size_t container_len = {}(buf, len, depth);", container_func(id));
                },
            }
            emit_line!(prod, "buf += container_len; len -= container_len;");
        },
        VariableType::ContainerRef(id) => {
            match grammar.options().depth() {
                Depth::Unlimited => {
                    emit_line!(prod, "size_t container_len = {}(buf, len);", container_func(id));
                },
                Depth::Limited(_) => {
                    emit_line!(prod, "size_t container_len = {}(buf, len, depth + 1);", container_func(id));
                },
            }
            emit_line!(prod, "buf += container_len; len -= container_len;");
        },
        VariableType::ResolveContainerRef(_) => panic!("Encountered unresolved container reference"),
    }
    
    if variable.options().repeats().is_some() {
        prod.block_close();
        emit_line!(prod, "}}");
    }
    
    if variable.options().optional() {
        prod.block_close();
        emit_line!(prod, "}}");
    }
    
    label_ref
}

fn emit_oneof(prod: &mut CodeFormatter, grammar: &Grammar, container: &Container) {
    let mut label_ref = false;
    
    match container.options().depth() {
        Depth::Unlimited => {
            emit_line!(prod, "static size_t {}(unsigned char* buf, size_t len) {{", container_func(&container.id()));
        },
        Depth::Limited(_) => {
            emit_line!(prod, "static size_t {}(unsigned char* buf, size_t len, uint64_t depth) {{", container_func(&container.id()));
        },
    }
    prod.block_open();
    
    emit_line!(prod, "size_t original_len = len;");
    
    match container.options().scheduling() {
        Scheduling::Random => {
            emit_line!(prod, "uint64_t oneof_selector = rand() % {};", container.variables().len());
        },
        Scheduling::RoundRobin => {
            emit_line!(prod, "static THREAD_LOCAL uint64_t oneof_cursor = 0;");
            emit_line!(prod, "uint64_t oneof_selector = oneof_cursor++ % {};", container.variables().len());
        },
    }
    
    emit_line!(prod, "switch(oneof_selector) {{");
    prod.block_open();
    
    for i in 0..container.variables().len() {
        emit_line!(prod, "case {}: {{", i);
        prod.block_open();
        label_ref |= emit_variable(prod, grammar, &container.variables()[i], container.options());
        emit_line!(prod, "break;");
        prod.block_close();
        emit_line!(prod, "}}");
    }
    
    emit_line!(prod, "default: {{");
    prod.block_open();
    emit_line!(prod, "__builtin_unreachable();");
    prod.block_close();
    emit_line!(prod, "}}");
    
    prod.block_close();
    emit_line!(prod, "}}");
    
    if label_ref {
        emit_line!(prod, "container_end:");
    }
    emit_line!(prod, "return original_len - len;");
    
    prod.block_close();
    emit_line!(prod, "}}");
}

fn emit_struct(prod: &mut CodeFormatter, grammar: &Grammar, container: &Container, view: &SourceView) {
    let mut label_ref = false;
    
    match container.options().depth() {
        Depth::Unlimited => {
            emit_line!(prod, "static size_t {}(unsigned char* buf, size_t len) {{", container_func(&container.id()));
        },
        Depth::Limited(_) => {
            emit_line!(prod, "static size_t {}(unsigned char* buf, size_t len, uint64_t depth) {{", container_func(&container.id()));
        },
    }
    
    prod.block_open();
    
    // Identifier comment
    if let Some(name) = &container.name() {
        if name.len() == 0 {
            let (line, col) = view.lineinfo(name.start);
            emit_line!(prod, "// This container is the anonymous struct in line {} column {}", line, col);
        } else {
            emit_line!(prod, "// This container is struct {}", view.range(name));
        }
    }
    
    emit_line!(prod, "size_t original_len = len;");
    
    for var in container.variables() {
        emit_line!(prod, "{{");
        prod.block_open();
        label_ref |= emit_variable(prod, grammar, var, container.options());
        prod.block_close();
        emit_line!(prod, "}}");
    }
    
    if label_ref {
        emit_line!(prod, "container_end:");
    }
    
    emit_line!(prod, "return original_len - len;");
    
    prod.block_close();
    emit_line!(prod, "}}");
}

fn emit_containers(prod: &mut CodeFormatter, grammar: &Grammar, view: &SourceView) {
    emit_raw!(prod, "\n// Definition of containers\n");
    
    for container in grammar.containers() {
        match container.typ() {
            ContainerType::Oneof => emit_oneof(prod, grammar, container),
            ContainerType::Struct => emit_struct(prod, grammar, container, view),
        }
    }
}

fn emit_entrypoint(prod: &mut CodeFormatter, args: &Args, grammar: &Grammar) {
    emit_raw!(
        prod,
"
// Entrypoint for the generator
size_t {}generate(unsigned char* buf, size_t len) {{
    if (UNLIKELY(!buf || !len)) {{
        return 0;
    }}
    
    return {}(buf, len{});
}}
",
        args.prefix,
        container_func(grammar.root().unwrap()),
        match grammar.options().depth() {
            Depth::Unlimited => "",
            Depth::Limited(_) => ", 1",
        },
    );
}

fn write_source(prod: &mut CodeFormatter, args: &Args, grammar: &Grammar, view: &SourceView) {
    emit_header(prod, args, grammar.options());
    emit_includes(prod);
    emit_macros(prod);
    emit_rng(prod, args);
    emit_helpers(prod);
    emit_strings(prod, grammar);
    emit_numbersets(prod, grammar);
    emit_declarations(prod, grammar);
    emit_containers(prod, grammar, view);
    emit_entrypoint(prod, args, grammar);
}

fn write_header(prod: &mut CodeFormatter, args: &Args) {
    emit_raw!(
        prod,
"
#ifndef __{0}GENERATOR_H
#define __{0}GENERATOR_H

#include <stddef.h>

size_t {0}generate(unsigned char* buf, size_t len);
void {0}seed(size_t initial_seed);

#endif /* __{0}GENERATOR_H */
",
        args.prefix
    )
}

fn c_stream(args: &Args) -> CodeFormatter {
    if args.outfile.as_ref().unwrap().as_str() == "-" {
        CodeFormatter::stdout()
    } else {
        CodeFormatter::file(&args.outfile.as_ref().unwrap())
    }
}

fn h_stream(args: &Args) -> CodeFormatter {
    if args.outfile.as_ref().unwrap().as_str() == "-" {
        CodeFormatter::stdout()
    } else {
        CodeFormatter::file(&format!("{}.h", args.outfile.as_ref().unwrap()))
    }
}

pub fn compile_grammar(args: &Args, grammar: &Grammar, view: &SourceView) {
    let mut outfile = h_stream(args);
    write_header(&mut outfile, args);
    let mut outfile = c_stream(args);
    write_source(&mut outfile, args, grammar, view);
}
