use crate::{
    Args,
    frontend::SourceView,
    grammar::{
        Grammar, StringId, NumbersetId, NumbersetType,
        Numberset, ContainerId, Container, ContainerType,
        Variable, VariableType, IntegerValue, BytearrayValue
    },
};
use std::io::{Write, Result, stdout};
use std::fs::File;
use std::fmt::Display;
use std::ops::Range;
use num_traits::{Num, cast::NumCast};

fn emit_header<T: Write>(stream: &mut T, args: &Args) -> Result<()> {
    write!(
        stream,
"
/************************************
     Auto-generated by Chameleon

              Parameters
             ~~~~~~~~~~~~
  Grammar: {}
  Allow cycles: {}
 ************************************/
",
        &args.grammar,
        args.allow_cycles
    )?;
    Ok(())
}

fn emit_includes<T: Write>(stream: &mut T) -> Result<()> {
    write!(
        stream,
"
#include <stddef.h>
#include <stdint.h>

void abort (void);
"
    )?;
    Ok(())
}

fn emit_macros<T: Write>(stream: &mut T) -> Result<()> {
    write!(
        stream,
"
// Mark globals as thread local only if we are doing multithreading
#ifdef MULTITHREADING
#define THREAD_LOCAL thread_local
#else
#define THREAD_LOCAL
#endif

// Define the compile-time seed
#ifndef SEED
#define SEED 0x35c6be9ba2548264
#endif
"
    )?;
    Ok(())
}

fn emit_rng<T: Write>(stream: &mut T, args: &Args) -> Result<()> {
    write!(
        stream,
"
// RNG: xorshift64
static THREAD_LOCAL uint64_t rand_state = SEED;

static uint64_t rand() {{
    uint64_t x = rand_state;
    x ^= x << 13;
    x ^= x >> 7;
    x ^= x << 17;
    return rand_state = x;
}}

void {}seed (size_t s) {{
    if (s) {{
        rand_state = (uint64_t) s;
    }} else {{
        rand_state = SEED;
    }}
}}
",
        &args.prefix,
    )?;
    Ok(())
}

fn string_var(id: &StringId) -> String {
    format!("string_{}", id)
}

fn emit_strings<T: Write>(stream: &mut T, grammar: &Grammar) -> Result<()> {
    if grammar.strings().len() > 0 {
        writeln!(stream, "")?;
        writeln!(stream, "// Strings from grammar")?;
        
        for (id, bts) in grammar.strings().iter() {
            write!(stream, "static unsigned char {}[{}] = {{", string_var(id), bts.len())?;
            
            for i in 0..bts.len() - 1 {
                write!(stream, "{:#02x}, ", bts[i])?;
            }
            write!(stream, "{:#02x}", bts[bts.len() - 1])?;
            
            writeln!(stream, "}};")?;
        }
    }
    
    Ok(())
}

fn numberset_func(id: &NumbersetId) -> String {
    format!("numberset_{}", id)
}

fn numberset_c_type(typ: &NumbersetType) -> &str {
    match typ {
        NumbersetType::U8(_) => "uint8_t",
        NumbersetType::I8(_) => "int8_t",
        NumbersetType::U16(_) => "uint16_t",
        NumbersetType::I16(_) => "int16_t",
        NumbersetType::U32(_) => "uint32_t",
        NumbersetType::I32(_) => "int32_t",
        NumbersetType::U64(_) => "uint64_t",
        NumbersetType::I64(_) => "int64_t",
    }
}

fn emit_range_selection<T: Write, R: Display + Ord + Num + NumCast + Copy>(stream: &mut T, range: &Range<R>, c_type: &str, suffix: &str) -> Result<()> {
    if range.end == range.start {
        write!(stream, "{}{}", range.start, suffix)?;
    } else {
        write!(stream, "((({}) rand()) % {}{}) + {}{}", c_type, range.end - range.start + R::from(1).unwrap(), suffix, range.start, suffix)?;
    }
    
    Ok(())
}

fn emit_single_numberset<T: Write, R: Display + Ord + Num + NumCast + Copy>(stream: &mut T, numberset: &Numberset<R>, c_type: &str, suffix: &str) -> Result<()> {
    if numberset.len() == 1 {
        write!(stream, "    return ")?;
        emit_range_selection(stream, &numberset[0], c_type, suffix)?;
        writeln!(stream, ";")?;
    } else {
        writeln!(stream, "    switch(rand() % {}) {{", numberset.len())?;
        
        for case in 0..numberset.len() {
            writeln!(stream, "        case {}: {{", case)?;
            write!(stream, "            return ")?;
            emit_range_selection(stream, &numberset[case], c_type, suffix)?;
            writeln!(stream, ";")?;
            writeln!(stream, "        }}")?;
        }
        
        writeln!(stream, "        default: {{")?;
        writeln!(stream, "            abort();")?;
        writeln!(stream, "        }}")?;
        
        writeln!(stream, "    }}")?;
    }
    
    Ok(())
}

fn emit_numbersets<T: Write>(stream: &mut T, grammar: &Grammar) -> Result<()> {
    if grammar.numbersets().len() > 0 {
        writeln!(stream, "")?;
        writeln!(stream, "// Numbersets from grammar")?;
        
        for (id, numberset) in grammar.numbersets().iter() {
            let c_type = numberset_c_type(numberset);
            writeln!(stream, "static {} {}() {{", c_type, numberset_func(id))?;
            
            match numberset {
                NumbersetType::U8(numberset) => emit_single_numberset(stream, numberset, c_type, "U")?,
                NumbersetType::I8(numberset) => emit_single_numberset(stream, numberset, c_type, "")?,
                NumbersetType::U16(numberset) => emit_single_numberset(stream, numberset, c_type, "U")?,
                NumbersetType::I16(numberset) => emit_single_numberset(stream, numberset, c_type, "")?,
                NumbersetType::U32(numberset) => emit_single_numberset(stream, numberset, c_type, "U")?,
                NumbersetType::I32(numberset) => emit_single_numberset(stream, numberset, c_type, "")?,
                NumbersetType::U64(numberset) => emit_single_numberset(stream, numberset, c_type, "UL")?,
                NumbersetType::I64(numberset) => emit_single_numberset(stream, numberset, c_type, "L")?,
            }
            
            writeln!(stream, "}}")?;
        }
    }
    
    Ok(())
}

fn container_func(id: &ContainerId) -> String {
    format!("container_{}", id)
}

fn emit_declarations<T: Write>(stream: &mut T, grammar: &Grammar) -> Result<()> {
    writeln!(stream, "")?;
    writeln!(stream, "// Forward declarations of containers")?;
    
    for container in grammar.containers() {
        writeln!(stream, "static size_t {}(unsigned char*, size_t);", container_func(&container.id()))?;
    }
    
    Ok(())
}

fn emit_variable<T: Write>(stream: &mut T, _grammar: &Grammar, _container: &Container, variable: &Variable) -> Result<()> {
    if variable.options().optional() {
        writeln!(stream, "        if (rand() & 1) {{")?;
    }
    
    if let Some(id) = variable.options().repeats() {
        writeln!(stream, "        uint32_t repeats_i = {}();", numberset_func(id))?;
        writeln!(stream, "        while (repeats_i--) {{")?;
    }
    
    match variable.typ() {
        VariableType::I8(integer) |
        VariableType::U8(integer) => {
            writeln!(stream, "        if (len >= 1) {{")?;
            match integer {
                IntegerValue::FromSet(id) => {
                    writeln!(stream, "            *buf = (unsigned char) {}();", numberset_func(id))?;
                },
                IntegerValue::Any => {
                    writeln!(stream, "            *buf = (unsigned char) rand();")?;
                },
            }
            writeln!(stream, "            buf += 1; len -= 1;")?;
            writeln!(stream, "        }}")?;
        },
        VariableType::I16(integer) |
        VariableType::U16(integer) => {
            writeln!(stream, "        if (len >= 2) {{")?;
            match integer {
                IntegerValue::FromSet(id) => {
                    writeln!(stream, "            *(uint16_t*)buf = (uint16_t) {}();", numberset_func(id))?;
                },
                IntegerValue::Any => {
                    writeln!(stream, "            *(uint16_t*)buf = (uint16_t) rand();")?;
                },
            }
            writeln!(stream, "            buf += 2; len -= 2;")?;
            writeln!(stream, "        }}")?;
        },
        VariableType::I32(integer) |
        VariableType::U32(integer) => {
            writeln!(stream, "        if (len >= 4) {{")?;
            match integer {
                IntegerValue::FromSet(id) => {
                    writeln!(stream, "            *(uint32_t*)buf = (uint32_t) {}();", numberset_func(id))?;
                },
                IntegerValue::Any => {
                    writeln!(stream, "            *(uint32_t*)buf = (uint32_t) rand();")?;
                },
            }
            writeln!(stream, "            buf += 4; len -= 4;")?;
            writeln!(stream, "        }}")?;
        },
        VariableType::I64(integer) |
        VariableType::U64(integer) => {
            writeln!(stream, "        if (len >= 8) {{")?;
            match integer {
                IntegerValue::FromSet(id) => {
                    writeln!(stream, "            *(uint64_t*)buf = (uint64_t) {}();", numberset_func(id))?;
                },
                IntegerValue::Any => {
                    writeln!(stream, "            *(uint64_t*)buf = (uint64_t) rand();")?;
                },
            }
            writeln!(stream, "            buf += 8; len -= 8;")?;
            writeln!(stream, "        }}")?;
        },
        VariableType::String(bytearray) => {
            match bytearray {
                BytearrayValue::Literal(id) => {
                    let var_name = string_var(id);
                },
                BytearrayValue::Any(id) => {
                    
                },
            }
        },
        _ => {},
    }
    
    if variable.options().repeats().is_some() {
        writeln!(stream, "        }}")?;
    }
    
    if variable.options().optional() {
        writeln!(stream, "        }}")?;
    }
    
    Ok(())
}

fn emit_oneof<T: Write>(_stream: &mut T, _grammar: &Grammar, _container: &Container, _view: &SourceView) -> Result<()> {
    //TODO
    Ok(())
}

fn emit_struct<T: Write>(stream: &mut T, grammar: &Grammar, container: &Container, view: &SourceView) -> Result<()> {
    writeln!(stream, "static size_t {}(unsigned char* buf, size_t len) {{", container_func(&container.id()))?;
    
    // Identifier comment
    if let Some(name) = &container.name() {
        if name.len() == 0 {
            let (line, col) = view.lineinfo(name.start);
            writeln!(stream, "    // This container is the anonymous struct in line {} column {}", line, col)?;
        } else {
            writeln!(stream, "    // This container is struct {}", view.range(name))?;
        }
    }
    
    writeln!(stream, "    size_t original_len = len;")?;
    
    for var in container.variables() {
        writeln!(stream,"    {{")?;
        emit_variable(stream, grammar, container, var)?;
        writeln!(stream,"    }}")?;
    }
    
    writeln!(stream, "    return original_len - len;")?;
    
    writeln!(stream, "}}")?;
    Ok(())
}

fn emit_containers<T: Write>(stream: &mut T, grammar: &Grammar, view: &SourceView) -> Result<()> {
    writeln!(stream, "")?;
    writeln!(stream, "// Definition of containers")?;
    
    for container in grammar.containers() {
        match container.typ() {
            ContainerType::Oneof => emit_oneof(stream, grammar, container, view)?,
            ContainerType::Struct => emit_struct(stream, grammar, container, view)?,
        }
    }
    
    Ok(())
}

fn write_file<T: Write>(args: &Args, grammar: &Grammar, view: &SourceView, mut stream: T) -> Result<()> {
    emit_header(&mut stream, args)?;
    emit_includes(&mut stream)?;
    emit_macros(&mut stream)?;
    emit_rng(&mut stream, args)?;
    emit_strings(&mut stream, grammar)?;
    emit_numbersets(&mut stream, grammar)?;
    emit_declarations(&mut stream, grammar)?;
    emit_containers(&mut stream, grammar, view)?;
    Ok(())
}

fn select_stream(args: &Args) -> Box<dyn Write> {
    if args.outfile.as_str() == "-" {
        Box::new(stdout())
    } else {
        Box::new(File::create(&args.outfile).expect("Could not create output file"))
    }
}

pub fn compile_grammar(args: &Args, grammar: &Grammar, view: &SourceView) {
    let outfile = select_stream(args);
    write_file(args, grammar, view, outfile).expect("Could not write to outfile");
}
