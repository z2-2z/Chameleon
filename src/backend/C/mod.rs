use crate::{
    Args,
    frontend::SourceView,
    grammar::{
        Grammar, StringId, NumbersetId, NumbersetType,
        Numberset, ContainerId, Container, ContainerType,
        Variable, VariableType, IntegerValue, BytearrayValue,
        Scheduling, HasOptions, Endianness,
    },
};
use std::io::{Write, Result, stdout};
use std::fs::File;
use std::fmt::Display;
use std::ops::Range;
use num_traits::{Num, cast::NumCast};

fn emit_header<T: Write>(stream: &mut T, args: &Args) -> Result<()> {
    write!(
        stream,
"
/************************************
     Auto-generated by Chameleon

              Parameters
             ~~~~~~~~~~~~
  Grammar: {}
  Allow cycles: {}
 ************************************/
",
        &args.grammar,
        args.allow_cycles
    )?;
    Ok(())
}

fn emit_includes<T: Write>(stream: &mut T) -> Result<()> {
    write!(
        stream,
"
#include <stddef.h>
#include <stdint.h>
#include <endian.h>
"
    )?;
    Ok(())
}

fn emit_macros<T: Write>(stream: &mut T) -> Result<()> {
    write!(
        stream,
"
#define UNLIKELY(x) __builtin_expect(!!(x), 0)
#define LIKELY(x) __builtin_expect(!!(x), 1)

#ifndef __clang__
#define __builtin_memcpy_inline __builtin_memcpy
#endif

// Mark globals as thread local only if we are doing multithreading
#ifdef MULTITHREADING
#define THREAD_LOCAL __thread
#else
#define THREAD_LOCAL
#endif

// Define the compile-time seed
#ifndef SEED
#define SEED 0x35c6be9ba2548264
#endif

// Define endianness helper functions
#define LITTLE_ENDIAN_16(x) htole16((uint16_t) (x))
#define BIG_ENDIAN_16(x)    htobe16((uint16_t) (x))
#define LITTLE_ENDIAN_32(x) htole32((uint32_t) (x))
#define BIG_ENDIAN_32(x)    htobe32((uint32_t) (x))
#define LITTLE_ENDIAN_64(x) htole64((uint64_t) (x))
#define BIG_ENDIAN_64(x)    htobe64((uint64_t) (x))
"
    )?;
    Ok(())
}

fn emit_rng<T: Write>(stream: &mut T, args: &Args) -> Result<()> {
    write!(
        stream,
"
// RNG: xorshift64
static THREAD_LOCAL uint64_t rand_state = SEED;

static uint64_t rand() {{
    uint64_t x = rand_state;
    x ^= x << 13;
    x ^= x >> 7;
    x ^= x << 17;
    return rand_state = x;
}}

void {}seed(size_t s) {{
    if (s) {{
        rand_state = (uint64_t) s;
    }} else {{
        rand_state = SEED;
    }}
}}
",
        &args.prefix,
    )?;
    Ok(())
}

fn emit_helpers<T: Write>(stream: &mut T) -> Result<()> {
    write!(
        stream,
"
// Helper method that writes random data into a buffer
#define MASK_BYTES 0xFFFFFFFFFFFFFFFFUL
#define MASK_STRING 0x7F7F7F7F7F7F7F7FUL
#ifndef DISABLE_random_buffer
static void random_buffer (unsigned char* buf, uint32_t len, uint64_t mask) {{
    while (len >= 8) {{
        *(uint64_t*)buf = rand() & mask;
        buf += 8; len -= 8;
    }}
    
    while (len >= 4) {{
        *(uint32_t*)buf = (uint32_t) (rand() & mask);
        buf += 4; len -= 4;
    }}
    
    while (len >= 2) {{
        *(uint16_t*)buf = (uint16_t) (rand() & mask);
        buf += 2; len -= 2;
    }}
    
    while (len >= 1) {{
        *buf = (unsigned char) (rand() & mask);
        buf += 1; len -= 1;
    }}
}}
#else
void random_buffer (unsigned char* buf, uint32_t len, uint64_t mask);
#endif
"
    )?;
    Ok(())
}

fn string_var(id: &StringId) -> String {
    format!("string_{}", id)
}

fn emit_strings<T: Write>(stream: &mut T, grammar: &Grammar) -> Result<()> {
    if grammar.strings().len() > 0 {
        writeln!(stream, "")?;
        writeln!(stream, "// Strings from grammar")?;
        
        for (id, bts) in grammar.strings().iter() {
            write!(stream, "static const unsigned char {}[{}] = {{", string_var(id), bts.len())?;
            
            for i in 0..bts.len() - 1 {
                write!(stream, "{:#02x}, ", bts[i])?;
            }
            write!(stream, "{:#02x}", bts[bts.len() - 1])?;
            
            writeln!(stream, "}};")?;
        }
    }
    
    Ok(())
}

fn numberset_func(id: &NumbersetId) -> String {
    format!("numberset_{}", id)
}

fn numberset_c_type(typ: &NumbersetType) -> &str {
    match typ {
        NumbersetType::U8(_) => "uint8_t",
        NumbersetType::I8(_) => "int8_t",
        NumbersetType::U16(_) => "uint16_t",
        NumbersetType::I16(_) => "int16_t",
        NumbersetType::U32(_) => "uint32_t",
        NumbersetType::I32(_) => "int32_t",
        NumbersetType::U64(_) => "uint64_t",
        NumbersetType::I64(_) => "int64_t",
    }
}

fn emit_range_selection<T: Write, R: Display + Ord + Num + NumCast + Copy>(stream: &mut T, range: &Range<R>, c_type: &str, suffix: &str) -> Result<()> {
    if range.end == range.start {
        write!(stream, "{}{}", range.start, suffix)?;
    } else {
        write!(stream, "((({}) rand()) % {}{}) + {}{}", c_type, range.end - range.start + R::from(1).unwrap(), suffix, range.start, suffix)?;
    }
    
    Ok(())
}

fn emit_single_numberset<T: Write, R: Display + Ord + Num + NumCast + Copy>(stream: &mut T, numberset: &Numberset<R>, c_type: &str, suffix: &str) -> Result<()> {
    if numberset.len() == 1 {
        write!(stream, "    return ")?;
        emit_range_selection(stream, &numberset[0], c_type, suffix)?;
        writeln!(stream, ";")?;
    } else {
        writeln!(stream, "    switch(rand() % {}) {{", numberset.len())?;
        
        for case in 0..numberset.len() {
            writeln!(stream, "        case {}: {{", case)?;
            write!(stream, "            return ")?;
            emit_range_selection(stream, &numberset[case], c_type, suffix)?;
            writeln!(stream, ";")?;
            writeln!(stream, "        }}")?;
        }
        
        writeln!(stream, "        default: {{")?;
        writeln!(stream, "            __builtin_unreachable();")?;
        writeln!(stream, "        }}")?;
        
        writeln!(stream, "    }}")?;
    }
    
    Ok(())
}

fn emit_numbersets<T: Write>(stream: &mut T, grammar: &Grammar) -> Result<()> {
    if grammar.numbersets().len() > 0 {
        writeln!(stream, "")?;
        writeln!(stream, "// Numbersets from grammar")?;
        
        for (id, numberset) in grammar.numbersets().iter() {
            let c_type = numberset_c_type(numberset);
            writeln!(stream, "static {} {}() {{", c_type, numberset_func(id))?;
            
            match numberset {
                NumbersetType::U8(numberset) => emit_single_numberset(stream, numberset, c_type, "U")?,
                NumbersetType::I8(numberset) => emit_single_numberset(stream, numberset, c_type, "")?,
                NumbersetType::U16(numberset) => emit_single_numberset(stream, numberset, c_type, "U")?,
                NumbersetType::I16(numberset) => emit_single_numberset(stream, numberset, c_type, "")?,
                NumbersetType::U32(numberset) => emit_single_numberset(stream, numberset, c_type, "U")?,
                NumbersetType::I32(numberset) => emit_single_numberset(stream, numberset, c_type, "")?,
                NumbersetType::U64(numberset) => emit_single_numberset(stream, numberset, c_type, "UL")?,
                NumbersetType::I64(numberset) => emit_single_numberset(stream, numberset, c_type, "L")?,
            }
            
            writeln!(stream, "}}")?;
        }
    }
    
    Ok(())
}

fn container_func(id: &ContainerId) -> String {
    format!("container_{}", id)
}

fn emit_declarations<T: Write>(stream: &mut T, grammar: &Grammar) -> Result<()> {
    writeln!(stream, "")?;
    writeln!(stream, "// Forward declarations of containers")?;
    
    for container in grammar.containers() {
        writeln!(stream, "static size_t {}(unsigned char*, size_t);", container_func(&container.id()))?;
    }
    
    Ok(())
}

fn emit_variable<T: Write>(stream: &mut T, variable: &Variable, endianness: &Endianness) -> Result<bool> {
    let mut label_ref = false;
    
    if variable.options().optional() {
        writeln!(stream, "        if (rand() & 1) {{")?;
    }
    
    if let Some(id) = variable.options().repeats() {
        writeln!(stream, "        uint32_t repeats_i = {}();", numberset_func(id))?;
        writeln!(stream, "        while (repeats_i--) {{")?;
    }
    
    match variable.typ() {
        VariableType::I8(integer) |
        VariableType::U8(integer) => {
            label_ref = true;
            writeln!(stream, "        if (UNLIKELY(len < 1)) {{")?;
            writeln!(stream, "            goto container_end;")?;
            writeln!(stream, "        }}")?;
            
            match integer {
                IntegerValue::FromSet(id) => {
                    writeln!(stream, "        *buf = (unsigned char) {}();", numberset_func(id))?;
                },
                IntegerValue::Any => {
                    writeln!(stream, "        *buf = (unsigned char) rand();")?;
                },
            }
            writeln!(stream, "        buf += 1; len -= 1;")?;
        },
        VariableType::I16(integer) |
        VariableType::U16(integer) => {
            label_ref = true;
            writeln!(stream, "        if (UNLIKELY(len < 2)) {{")?;
            writeln!(stream, "            goto container_end;")?;
            writeln!(stream, "        }}")?;
            
            match integer {
                IntegerValue::FromSet(id) => {
                    writeln!(stream, "        uint16_t integer = (uint16_t) {}();", numberset_func(id))?;
                },
                IntegerValue::Any => {
                    writeln!(stream, "        uint16_t integer = (uint16_t) rand();")?;
                },
            }
            
            match endianness {
                Endianness::Little => {
                    writeln!(stream, "        *(uint16_t*)buf = LITTLE_ENDIAN_16(integer);", )?;
                },
                Endianness::Big => {
                    writeln!(stream, "        *(uint16_t*)buf = BIG_ENDIAN_16(integer);", )?;
                },
                Endianness::Native => {
                    writeln!(stream, "        *(uint16_t*)buf = integer;", )?;
                },
            }
            
            writeln!(stream, "        buf += 2; len -= 2;")?;
        },
        VariableType::I32(integer) |
        VariableType::U32(integer) => {
            label_ref = true;
            writeln!(stream, "        if (UNLIKELY(len < 4)) {{")?;
            writeln!(stream, "            goto container_end;")?;
            writeln!(stream, "        }}")?;
            
            match integer {
                IntegerValue::FromSet(id) => {
                    writeln!(stream, "        uint32_t integer = (uint32_t) {}();", numberset_func(id))?;
                },
                IntegerValue::Any => {
                    writeln!(stream, "        uint32_t integer = (uint32_t) rand();")?;
                },
            }
            
            match endianness {
                Endianness::Little => {
                    writeln!(stream, "        *(uint32_t*)buf = LITTLE_ENDIAN_32(integer);", )?;
                },
                Endianness::Big => {
                    writeln!(stream, "        *(uint32_t*)buf = BIG_ENDIAN_32(integer);", )?;
                },
                Endianness::Native => {
                    writeln!(stream, "        *(uint32_t*)buf = integer;", )?;
                },
            }
            
            writeln!(stream, "        buf += 4; len -= 4;")?;
        },
        VariableType::I64(integer) |
        VariableType::U64(integer) => {
            label_ref = true;
            writeln!(stream, "        if (UNLIKELY(len < 4)) {{")?;
            writeln!(stream, "            goto container_end;")?;
            writeln!(stream, "        }}")?;
            
            match integer {
                IntegerValue::FromSet(id) => {
                    writeln!(stream, "        uint64_t integer = (uint64_t) {}();", numberset_func(id))?;
                },
                IntegerValue::Any => {
                    writeln!(stream, "        uint64_t integer = (uint64_t) rand();")?;
                },
            }
            
            match endianness {
                Endianness::Little => {
                    writeln!(stream, "        *(uint64_t*)buf = LITTLE_ENDIAN_64(integer);", )?;
                },
                Endianness::Big => {
                    writeln!(stream, "        *(uint64_t*)buf = BIG_ENDIAN_64(integer);", )?;
                },
                Endianness::Native => {
                    writeln!(stream, "        *(uint64_t*)buf = integer;", )?;
                },
            }
            
            writeln!(stream, "        buf += 8; len -= 8;")?;
        },
        VariableType::String(bytearray) => {
            label_ref = true;
            match bytearray {
                BytearrayValue::Literal(id) => {
                    let var_name = string_var(id);
                    writeln!(stream, "        if (UNLIKELY(len < sizeof({}))) {{", var_name)?;
                    writeln!(stream, "            goto container_end;")?;
                    writeln!(stream, "        }}")?;
                    writeln!(stream, "        __builtin_memcpy_inline(buf, {0}, sizeof({0}));", var_name)?;
                    writeln!(stream, "        buf += sizeof({0}); len -= sizeof({0});", var_name)?;
                },
                BytearrayValue::Any(id) => {
                    writeln!(stream, "        uint32_t string_len = {}();", numberset_func(id))?;
                    writeln!(stream, "        if (UNLIKELY(len < string_len)) {{")?;
                    writeln!(stream, "            goto container_end;")?;
                    writeln!(stream, "        }}")?;
                    writeln!(stream, "        random_buffer(buf, string_len, MASK_STRING);")?;
                    writeln!(stream, "        buf += string_len; len -= string_len;")?;
                },
            }
        },
        VariableType::Bytes(bytearray) => {
            label_ref = true;
            match bytearray {
                BytearrayValue::Literal(id) => {
                    let var_name = string_var(id);
                    writeln!(stream, "        if (UNLIKELY(len < sizeof({}))) {{", var_name)?;
                    writeln!(stream, "            goto container_end;")?;
                    writeln!(stream, "        }}")?;
                    writeln!(stream, "        __builtin_memcpy_inline(buf, {0}, sizeof({0}));", var_name)?;
                    writeln!(stream, "        buf += sizeof({0}); len -= sizeof({0});", var_name)?;
                },
                BytearrayValue::Any(id) => {
                    writeln!(stream, "        uint32_t bytes_len = {}();", numberset_func(id))?;
                    writeln!(stream, "        if (UNLIKELY(len < bytes_len)) {{")?;
                    writeln!(stream, "            goto container_end;")?;
                    writeln!(stream, "        }}")?;
                    writeln!(stream, "        random_buffer(buf, bytes_len, MASK_BYTES);")?;
                    writeln!(stream, "        buf += bytes_len; len -= bytes_len;")?;
                },
            }
        },
        VariableType::Oneof(id) |
        VariableType::ContainerRef(id) => {
            writeln!(stream, "        size_t container_len = {}(buf, len);", container_func(id))?;
            writeln!(stream, "        buf += container_len; len -= container_len;")?;
        },
        VariableType::ResolveContainerRef(_) => panic!("Encountered unresolved container reference"),
    }
    
    if variable.options().repeats().is_some() {
        writeln!(stream, "        }}")?;
    }
    
    if variable.options().optional() {
        writeln!(stream, "        }}")?;
    }
    
    Ok(label_ref)
}

fn emit_oneof<T: Write>(stream: &mut T, container: &Container) -> Result<()> {
    let mut label_ref = false;
    
    writeln!(stream, "static size_t {}(unsigned char* buf, size_t len) {{", container_func(&container.id()))?;
    writeln!(stream, "    size_t original_len = len;")?;
    
    match container.options().scheduling() {
        Scheduling::Random => {
            writeln!(stream, "    uint64_t oneof_selector = rand() % {};", container.variables().len())?;
        },
        Scheduling::RoundRobin => {
            writeln!(stream, "    static THREAD_LOCAL uint64_t oneof_cursor = 0;")?;
            writeln!(stream, "    uint64_t oneof_selector = oneof_cursor++ % {};", container.variables().len())?;
        },
    }
    
    writeln!(stream, "    switch(oneof_selector) {{")?;
    
    for i in 0..container.variables().len() {
        writeln!(stream, "        case {}: {{", i)?;
        label_ref |= emit_variable(stream, &container.variables()[i], container.options().endianness())?;
        writeln!(stream, "        break;")?;
        writeln!(stream, "        }}")?;
    }
    
    writeln!(stream, "        default: {{")?;
    writeln!(stream, "            __builtin_unreachable();")?;
    writeln!(stream, "        }}")?;
    
    writeln!(stream, "    }}")?;
    
    if label_ref {
        writeln!(stream, "  container_end:")?;
    }
    writeln!(stream, "    return original_len - len;")?;
    writeln!(stream, "}}")?;
    Ok(())
}

fn emit_struct<T: Write>(stream: &mut T, container: &Container, view: &SourceView) -> Result<()> {
    let mut label_ref = false;
    
    writeln!(stream, "static size_t {}(unsigned char* buf, size_t len) {{", container_func(&container.id()))?;
    
    // Identifier comment
    if let Some(name) = &container.name() {
        if name.len() == 0 {
            let (line, col) = view.lineinfo(name.start);
            writeln!(stream, "    // This container is the anonymous struct in line {} column {}", line, col)?;
        } else {
            writeln!(stream, "    // This container is struct {}", view.range(name))?;
        }
    }
    
    writeln!(stream, "    size_t original_len = len;")?;
    
    for var in container.variables() {
        writeln!(stream,"    {{")?;
        label_ref |= emit_variable(stream, var, container.options().endianness())?;
        writeln!(stream,"    }}")?;
    }
    
    if label_ref {
        writeln!(stream, "  container_end:")?;
    }
    writeln!(stream, "    return original_len - len;")?;
    writeln!(stream, "}}")?;
    Ok(())
}

fn emit_containers<T: Write>(stream: &mut T, grammar: &Grammar, view: &SourceView) -> Result<()> {
    writeln!(stream, "")?;
    writeln!(stream, "// Definition of containers")?;
    
    for container in grammar.containers() {
        match container.typ() {
            ContainerType::Oneof => emit_oneof(stream, container)?,
            ContainerType::Struct => emit_struct(stream, container, view)?,
        }
    }
    
    Ok(())
}

fn emit_entrypoint<T: Write>(stream: &mut T, args: &Args, grammar: &Grammar) -> Result<()> {
    write!(
        stream,
"
// Entrypoint for the generator
size_t {}generate(unsigned char* buf, size_t len) {{
    if (UNLIKELY(!buf || !len)) {{
        return 0;
    }}
    
    return {}(buf, len);
}}
",
        args.prefix,
        container_func(grammar.root().unwrap()),
    )?;
    
    Ok(())
}

fn write_source<T: Write>(args: &Args, grammar: &Grammar, view: &SourceView, mut stream: T) -> Result<()> {
    emit_header(&mut stream, args)?;
    emit_includes(&mut stream)?;
    emit_macros(&mut stream)?;
    emit_rng(&mut stream, args)?;
    emit_helpers(&mut stream)?;
    emit_strings(&mut stream, grammar)?;
    emit_numbersets(&mut stream, grammar)?;
    emit_declarations(&mut stream, grammar)?;
    emit_containers(&mut stream, grammar, view)?;
    emit_entrypoint(&mut stream, args, grammar)?;
    Ok(())
}

fn write_header<T: Write>(args: &Args, mut stream: T) -> Result<()> {
    write!(
        &mut stream,
"
#ifndef __{0}GENERATOR_H
#define __{0}GENERATOR_H

#include <stddef.h>

size_t {0}generate(unsigned char* buf, size_t len);
void {0}seed(size_t initial_seed);

#endif /* __{0}GENERATOR_H */
",
        args.prefix
    )?;
    
    Ok(())
}

fn c_stream(args: &Args) -> Box<dyn Write> {
    if args.outfile.as_str() == "-" {
        Box::new(stdout())
    } else {
        Box::new(File::create(&args.outfile).expect("Could not create source file"))
    }
}

fn h_stream(args: &Args) -> Box<dyn Write> {
    if args.outfile.as_str() == "-" {
        Box::new(stdout())
    } else {
        Box::new(File::create(format!("{}.h", args.outfile)).expect("Could not create header file"))
    }
}

pub fn compile_grammar(args: &Args, grammar: &Grammar, view: &SourceView) {
    let outfile = c_stream(args);
    write_source(args, grammar, view, outfile).expect("Could not write to source file");
    let outfile = h_stream(args);
    write_header(args, outfile).expect("Could not write to header file");
}
